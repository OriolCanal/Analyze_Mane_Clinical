import os
import subprocess
import re

from models.log import Log

class Vep():

    def __init__(self, ref_conf_obj, ann_conf_obj, docker_conf_obj, genome_version):
        self.vep_version = ann_conf_obj.vep.version
        self.genome_version = genome_version
        self.vep_cmd = []
        self.vep_sv_cmd = []
        self.ref_conf = ref_conf_obj.get_genome_data(self.genome_version)
        self.ann_conf = ann_conf_obj
        self.docker_conf_vep = docker_conf_obj.vep
        self.vep_ann_dir = "/anndir/"

    def run_vep(self, Vcf, structural_variants=False):
        """
        Run the Variant Effect Predictor (VEP) tool on the specified VCF file.

        Parameters:
        -----------
        vcf_file : str
            The path to the VCF file to be analyzed.
        structural_variants : bool, optional
            Flag indicating whether the VCF file contains structural variants.
            Defaults to False.

        Returns:
        --------
        str
            The path to the output file generated by VEP.
        """
        vcf_file = Vcf.path
        vep_cmd = self.get_vep_cmd(vcf_file, structural_variants)
        joined_cmd = " ".join(self.vep_cmd)
        self.get_output_path(vcf_file)
        if os.path.exists(self.output_path):
            Log.info(f"VEP output file already exists: {self.output_path}\nVEP won't be run")
            Vcf.set_annotated_vcf(self.get_output_path(vcf_file))
            return(self.get_output_path(vcf_file))
        Log.info(f"Running vep over {vcf_file}:\n{joined_cmd}")
        try:
            result = subprocess.run(vep_cmd, encoding="utf-8", capture_output=True)

        except subprocess.CalledProcessError as e:
            Log.error("Error running Docker command:", e)
            Log.error("STDOUT:", e.stdout.decode())
            Log.error("STDERR:", e.stderr.decode())
            Log.error("stdout:", result.stdout)
            Log.error("stderr", result.stderr)

        Vcf.set_annotated_vcf(self.get_output_path(vcf_file))
        return (self.get_output_path(vcf_file))
    
    def get_vep_cmd(self, vcf_file, structural_variants=False):
        """
        Get all the parameters to run VEP including flags , plugins...
        params:
            vcf_file(str): vcf file path
            structural_variants(bool): does the vcf_file contain structural_varaints? If True it wil
                analyze variants with 500000 length, if False until 100 pb
        
        return:
            self.vep_cmd(str): vep command containing all plugins, flags and custom anns
        """
        uid = os.getuid()
        gid = os.getgid()
        self.vep_cmd = [
            "/usr/bin/docker", # path to the Docker executable
            "run", # run a command in a new container
            "-u", # specify the userID 
            f"{uid}:{gid}", # id -u returns the userID of current user, id -g returns groupid of current user
            "-t", # to interact with container using terminal
            "-i" # allow interact with container shell
        ]
        self.add_genome_ref_dir()
        self.add_ann_dir()
        self.add_dir_cahce()
        self.add_vcf_dir(vcf_file)
        self.add_vep_image()
        self.add_flags(vcf_file, structural_variants)
        self.add_dbnsfp()
        self.add_spliceai()
        self.add_maxentscan()
        self.add_revel()
        self.add_gnomad_genomes()
        self.add_gnomad_exomes()
        self.add_1000_genomes()
        self.add_cadd()
        self.add_clinvar()
        self.add_fasta()
    
        return(self.vep_cmd)


    def get_ann_vep_path(self, resource):
        """
        joins annotation relative path with the path created for annotation volume in the vep_container
        """
        if hasattr(self.ann_conf, resource):
            resource_obj = getattr(self.ann_conf, resource)
            resource_rel_path = resource_obj.ann_relative_path
            vep_resource_path = os.path.join(self.vep_ann_dir, resource_rel_path)
        else:
            raise ValueError(f"Resource {resource} not in annotations_yaml")

        return(vep_resource_path)
    
    def add_fasta(self):
        """
        Add FASTA file path to VEP command.

        Appends the path to the FASTA file, specified in `ref_conf`,
        to the VEP command.
        """
        fasta_vep_path = os.path.join(self.vep_genome_dir, self.ref_conf.fasta)
        self.vep_cmd.extend(
            [
                "--fasta",
                f"{fasta_vep_path}"
            ]
        )
    def get_output_path(self, vcf_file):
        """
        Get the output path for VEP-annotated VCF file.

        Parameters:
        -----------
        vcf_file : str
            The path to the input VCF file.

        Returns:
        --------
        str
            The path to the output VEP-annotated VCF file.
        """
        vcf_dir = os.path.dirname(vcf_file)
        vcf_filename = os.path.basename(vcf_file)
        output_vcf_filename = f"vep_{vcf_filename}"
        self.output_path = os.path.join(vcf_dir, output_vcf_filename)

        return (self.output_path)

    def add_flags(self, vcf_file, structural_variants=False):
        """
        Add flags and options to the VEP command.

        Constructs and adds flags and options to the VEP command (self.vep_cmd) based on the
        provided parameters and configuration settings.

        Parameters:
        -----------
        vcf_file : str
            The path to the input VCF file.
        structural_variants : bool, optional
            Flag indicating whether the input VCF file contains structural variants.
            Defaults to False.

        Returns:
        --------
        None
        """
        plugins_dir = os.path.join(self.vep_cache_dir, "Plugins")
        input_vcf_filename = os.path.basename(vcf_file)
        output_vcf_filename = f"vep_{input_vcf_filename}"
        input_vep_file_path = os.path.join(self.vep_vcf_dir, input_vcf_filename)
        output_vep_file_path = os.path.join(self.vep_vcf_dir, output_vcf_filename)

        # flags for sv should contain a higher sv_size and buffer size
        if structural_variants:
            sv_size = 500000
            buffer_flag = "--buffer_size"
            buffer_value = "500"
        else:
            sv_size = 100
            buffer_flag = ""
            buffer_value = ""

        if self.genome_version == "hg38":
            assembly = "GRCh38"
        elif self.genome_version == "hg19":
            assembly = "GRCh37"
        else:
            raise ValueError(f"assembly not defined for genome version {self.genome_version}")
        
        self.vep_cmd.extend(
            [
                "--cache",
                "--offline",
                "--dir_cache", f"{self.vep_cache_dir}",
                "--dir_plugins", f"{plugins_dir}",
                "--input_file", f"{input_vep_file_path}",
                "--output_file", f"{output_vep_file_path}",
                "--assembly", f"{assembly}",
                "--af_1kg",
                "--af_gnomad",
                "--cache_version", f"{self.ann_conf.vep_cache.version}",
                "--canonical",
                "--format", "vcf",
                "--vcf",
                "--hgvs",
                "--mane",
                "--mane_select",
                "--xref_refseq",
                "--hgvsg",
                "--max_af",
                "--pubmed",
                "--gene_phenotype",
                "--max_sv_size", f"{sv_size}",
                "--ccds",
                "--sift", "b",
                "--polyphen", "b",
                "--symbol",
                "--force_overwrite",
                "--fork", "4"
            ]
        )
        if structural_variants:
            self.vep_cmd.extend(
                [
                    f"{buffer_flag}",
                    f"{buffer_value}",
                ]
            )

    def add_vep_image(self):
        """
        Add the VEP Docker image to the VEP command.

        Appends the VEP Docker image name and the command to run VEP
        ("vep") to the list of VEP command components (`vep_cmd`).

        Returns:
        --------
        None
        """
        vep_docker_image = self.docker_conf_vep["image"]
        self.vep_cmd.extend(
            [
                vep_docker_image,
                "vep"
            ]
        )
    def add_dbnsfp(self):
        fields = self.ann_conf.dbnsfp.fields
        # print(fields, "dbnsfp_fields", type(fields))
        str_fields = ",".join(fields)
        dbnsfp_vep_path = self.get_ann_vep_path("dbnsfp")
        self.vep_cmd.extend(
            [
                "--plugin",
                f"{self.ann_conf.dbnsfp.resource_name},{dbnsfp_vep_path},{str_fields}"
            ]
        )

    def add_spliceai(self):
        snv_vep_relative_path = self.get_ann_vep_path("spliceai_snv")
        indel_vep_relative_path = self.get_ann_vep_path("spliceai_indel")
        self.vep_cmd.extend(
            [
                "--plugin",
                f"SpliceAI,snv={snv_vep_relative_path},indel={indel_vep_relative_path}"
            ]
        )

    def add_maxentscan(self):
        # maxentscan works both on hg19 and 38 equally (it is based on sequence) so we just need to give the resource dir
        maxent_vep_path = self.get_ann_vep_path("maxent")
        self.vep_cmd.extend(
            [
                "--plugin",
                f"{self.ann_conf.maxent.resource_name},{maxent_vep_path}"
            ]
        )
    
    def add_revel(self):
        revel_vep_path = self.get_ann_vep_path("revel")
        self.vep_cmd.extend(
            [
                "--plugin",
                f"{self.ann_conf.revel.resource_name},{revel_vep_path}"
            ]
        )
    
    def add_phastcons(self):
        phastcons_vep_path = self.get_ann_vep_path("phastcons")
        self.vep_cmd.extend(
            [
                "--custom",
                f"{phastcons_vep_path},{self.ann_conf.phastcons.resource_name},bigwig,overlap"
            ]
        )
    
    def add_phylop(self):
        phylop_vep_path = self.get_ann_vep_path("phylop")
        self.vep_cmd.extend(
            [
                "--custom",
                f"{phylop_vep_path},{self.ann_conf.phylop.resource_name},bigwig,overlap"
            ]
        )

    def add_gnomad_genomes(self):
        gnomad_genomes_vep_path = self.get_ann_vep_path("gnomad")
        fields = self.ann_conf.gnomad.fields
        fields_str = ",".join(fields)
        self.vep_cmd.extend(
            [   
                "--custom",
                f"{gnomad_genomes_vep_path},{self.ann_conf.gnomad.resource_name},vcf,exact,0,{fields_str}"
            ]
        )
    
    def add_gnomad_exomes(self):
        gnomad_exomes_vep_path = self.get_ann_vep_path("gnomad_exomes")
        fields = self.ann_conf.gnomad_exomes.fields
        fields_str = ",".join(fields)
        self.vep_cmd.extend(
            [
                "--custom",
                f"{gnomad_exomes_vep_path},{self.ann_conf.gnomad_exomes.resource_name},vcf,exact,0,{fields_str}"
            ]
        )
    
    def add_1000_genomes(self):
        thousand_genomes_vep_path = self.get_ann_vep_path("thousand_genomes")
        fields = self.ann_conf.thousand_genomes.fields
        fields_str = ",".join(fields)
        self.vep_cmd.extend(
            [
                "--custom",
                f"{thousand_genomes_vep_path},{self.ann_conf.gnomad_exomes.resource_name},vcf,exact,0,{fields_str}"
            ]
        )
    
    def add_cadd(self, structural_variants=False):
        if structural_variants:
            # from vep documentation to annotate sv with cadd we use this flag
            cadd_sv = ",force_annotate=1"
        else:
            cadd_sv = ""
        cadd_vep_path = self.get_ann_vep_path("cadd")
        self.vep_cmd.extend(
            [
                "--plugin",
                f"{self.ann_conf.cadd.resource_name},{cadd_vep_path}{cadd_sv}"
            ]
        )
    
    def add_clinvar(self):
        clinvar_vep_path = self.get_ann_vep_path("clinvar")
        fields = self.ann_conf.clinvar.fields
        fields_str = ",".join(fields)
        self.vep_cmd.extend(
            [
                "--custom",
                f"{clinvar_vep_path},{self.ann_conf.clinvar.resource_name},vcf,exact,0,{fields_str}"
            ]
        )

    def add_genome_ref_dir(self):
        self.vep_genome_dir = "/genomedir/"
        self.vep_cmd.extend(["-v", f"{self.ref_conf.dir_path}:{self.vep_genome_dir}"])
    
    def add_ann_dir(self):
        self.vep_cmd.extend(["-v", f"{self.ann_conf.ann_dir}:{self.vep_ann_dir}"])

    def add_dir_cahce(self):
        self.vep_cache_dir = "/opt/vep/.vep"
        self.vep_cmd.extend(["-v", f"{self.ann_conf.vep.dir_path}:{self.vep_cache_dir}"])

    def add_vcf_dir(self, vcf_file):
        vcf_dir = os.path.dirname(vcf_file)
        self.vep_vcf_dir = "/vcf_file/"
        self.vep_cmd.extend(["-v", f"{vcf_dir}:{self.vep_vcf_dir}"])
    
    def add_volumes(self):
        self.add_genome_ref_dir()
        self.add_ann_dir()
        self.add_vep_dir()
        self.add_vcf_dir()

class Vep_vcf():
    def __init__(self, vep_vcf):
        self.path = vep_vcf
        self.ann_fields = list()
        self.variants = list()
    
    def add_variant(self, Vep_variant):
        self.variants.append(Vep_variant)

    def get_ann_fields(self):
        with open(self.path, "r") as f:
            for line in f:
                if not line.startswith("#"):
                    break
                if not line.startswith("##INFO=<ID=CSQ"):
                    continue
                # print(line)
                # after Format: there are all annotations tags used by vep
                pattern = r"Format:\s*(.+?)\s*\">"
                match = re.search(pattern, line)

                vep_fields = match.group(1)
                
                vep_fields_list = vep_fields.split("|")

                for i, vep_field in enumerate(vep_fields_list):
                    self.ann_fields.append(vep_field)
                    # self.ann_indices[vep_field] = i
                    # self.indice_ann[i] = vep_field
        return(self.ann_fields)
    def get_variants(self):
        with open(self.path, "r") as f:
            for line in f:
                if line.startswith("#"):
                    continue

                chr, pos, id, ref, alt, qual, filter, info, format, other = line.split("\t")

                info_values = info.split(";")
                for info_value in info_values:
                    if info_value.startswith("CSQ="):
                        yield(chr, pos, ref, alt, info_value)
                



class Vep_variant():
    def __init__(self, chr, pos, ref, alt, vep_anns):
        self.chr = chr
        self.pos = pos
        self.ref = ref
        self.alt = alt
        self.annotations_str = vep_anns.split(",")
        self.annotations = list()

    def parse_ann(self, vep_fields:list):
        for ann_str in self.annotations_str:
            annotation_values =  ann_str.split("|")
            if len(vep_fields) != len(annotation_values):
                raise ValueError(
                    f"Length of annotation items is not equal to length of header vep fields: annotations: {len(annotation_values)}, vep fields:{len(vep_fields)}"
                )
            
            self.annotations.append(dict(zip(vep_fields, annotation_values)))

# class Variant_annotation():
#     def __init__(self, ann_str):
#         self.annotations = ann_str
    
#     def parse_ann(self, ann_fields):
#         annotations = self.ann_str.split("|")
#         if len(annotations) != len(ann_fields):
#             raise ValueError(
#                 f"Length of annotation items is not equal to length of header vep fields: annotations: {len(annotations)}, vep fields:{len(ann_fields)}"
#             )
        
#         self.annotations = dict(zip(ann_fields, annotations))


    